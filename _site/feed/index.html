<?xml version="1.0" encoding="utf-8"?>
  <rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>jaminzzhang</title>
    <link href="http://jaminzzhang.github.com/feed/" rel="self" />
    <link href="http://webfrogs.github.com" />
    <lastBuildDate>2014-06-01T22:55:21+08:00</lastBuildDate>
    <webMaster>ccf.developer@gmail.com</webMaster>
    
    <item>
      <title>我的第一篇文章</title>
      <link href="http://jaminzzhang.github.com/2014/02/28/My-First-Post/"/>
      <pubDate>2014-02-28T00:00:00+08:00</pubDate>
      <author>jaminzzhang</author>
      <guid>http://jaminzzhang.github.com/2014/02/28/My-First-Post</guid>
      <content:encoded><![CDATA[<h2>我的第一篇文章</h2>

<p>我的第一篇githubpage的文章</p>
<p>28 Feb 2014</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>iOS文件操作(IO)的Benchmark</title>
      <link href="http://jaminzzhang.github.com/2014/01/15/Benchmark-Of-IO/"/>
      <pubDate>2014-01-15T00:00:00+08:00</pubDate>
      <author>jaminzzhang</author>
      <guid>http://jaminzzhang.github.com/2014/01/15/Benchmark-Of-IO</guid>
      <content:encoded><![CDATA[<h2>iOS文件操作(IO)的Benchmark</h2>


<p>一直想看看iOS的IO性能到底怎么样，所以就有了这次的文件操作的benchmark，让我们看看各种文件操作的效率。<br/>
测试工具：Xcode 5.0.2 (5A3005) XCTest<br/>
测试设备：iPod 5 32G<br/>
测试代码：https://github.com/jaminzzhang/FileManagerBenchmark.git</p>

<p>&nbsp;</p>

<h2>1、读取文件信息</h2>

<h4>1）检查文件是否存在</h4>

<p>API:</p>

<div>
<pre><code>- (BOOL)fileExistsAtPath:(NSString *)path;
- (BOOL)fileExistsAtPath:(NSString *)path isDirectory:(BOOL *)isDirectory;</code></pre>
</div>


<p>Benchmark结果：<br/>
目标路径文件存在<br/>
SEL(fileExistsAtPath:)                次数：10000次(1W次)         耗时：2.880s ~ 2.890s<br/>
SEL(fileExistsAtPath:isDirectory:)    次数：10000次(1W次)         耗时：2.890s ~ 2.900s</p>

<p>目标路径文件不存在 <br/>
次数：10000次       耗时：0.500 ~ 0.510s</p>

<p>从结果可以看到，检查的目标路径的文件存在耗时为0.2880ms，0.2880ms是什么概念？就是相当于NSArray使用快速遍历(NSFastEnumeration)1000个左右元素。而加入isDirectory是否目录的判断对效率的影响微乎极微。但需要注意的是，假如目标路径的文件不存在，耗时则非常少，即判断一个不存在的文件是否存在的耗时非常之少，所以，估计当判断到文件存在之后，还读取了文件一系列信息，包括是否是路径，是否是软链接等。</p>

<p><em>ps：假如目标路径的文件是软链接文件，fileExistsAtPath会源溯到该软链接文件的目标路径来检查文件是否存在(If the final element in path specifies a symbolic link, this method traverses the link and returns YES or NO based on the existence of the file at the link destination.)。因此检查软链文件是否存在的时候需要特别注意，如检查到软链文件对应的目标路径文件不存在（实际软链还存在），此时再去创建一个软链文件的话会报错，说软链文件已存在。</em></p>

<h4>2）获取文件信息</h4>

<p>API</p>

<div>
<pre><code>- (NSDictionary *)attributesOfItemAtPath:(NSString *)path error:(NSError **)error</code></pre>
</div>


<p>Benchmark结果：<br/>
文件        次数：10000次(1W次)        耗时：11.800s ~ 11.900s<br/>
文件夹    次数：10000次(1W次)          耗时：5.700s ~ 5.800s</p>

<h4>3）遍历文件</h4>

<p>API</p>

<div>
<pre><code>
- (NSArray *)subpathsOfDirectoryAtPath:(NSString *)path error:(NSError **)error (- (NSArray *)subpathsAtPath:(NSString *)path)
- (NSArray *)contentsOfDirectoryAtPath:(NSString *)path error:(NSError **)error (- (NSArray *)directoryContentsAtPath:(NSString *)path)
- (NSDirectoryEnumerator *)enumeratorAtPath:(NSString *)path;
- (NSDirectoryEnumerator *)enumeratorAtURL:(NSURL *)url includingPropertiesForKeys:(NSArray *)keys options:(NSDirectoryEnumerationOptions)mask errorHandler:(BOOL (^)(NSURL *url, NSError *error))handler</code></pre>
</div>


<p>&nbsp;
Benchmark结果：</p>

<p>1级目录(10000个文件)：
SEL(contentsOfDirectoryAtPath:error:)                                                                      文件数：10000                耗时：0.070s ~ 0.080s<br/>
SEL(subpathsOfDirectoryAtPath:error:)                                                                     文件数：10000                耗时：0.230s ~ 0.240s<br/>
SEL(enumeratorAtPath:)                                                                                            文件数：10000                耗时：5.000s ~ 5.200s<br/>
SEL(enumeratorAtURL:includingPropertiesForKeys:options:errorHandler:)             文件数：10000次             耗时：0.410s ~ 0.420s</p>

<p>2级目录(两个层级，每个层级10000个文件，共两万个文件)：<br/>
SEL(contentsOfDirectoryAtPath:error:)                                                                      文件数：10000                 耗时：0.070s ~   0.080s SEL(subpathsOfDirectoryAtPath:error:)                                                                     文件数：20000                 耗时：0.460s ~ 0.470s<br/>
SEL(enumeratorAtPath:)                                                                                            文件数：20000                 耗时：10.310s ~ 10.320s<br/>
SEL(enumeratorAtURL:includingPropertiesForKeys:options:errorHandler:)             文件数：20000次              耗时：0.790s ~ 0.800s</p>

<p>上述几个遍历的方法，除了SEL(contentsOfDirectoryAtPath:error:)是浅遍历（即不会递归遍历子目录）之外，其他的方法都可以进行深入递归遍历。从结果看，SEL(enumeratorAtPath:)性能之低，实在让人感觉到惊奇，该方法适用于大型的文件系统树(Because the enumeration is deep—that is, it lists the contents of all subdirectories—this enumerator object is useful for performing actions that involve large file-system subtrees)，以时间换空间，但enumeratorAtURL明显是更高效的方法； 假如需要获取遍历目录下文件的信息，SEL(enumeratorAtURL:includingPropertiesForKeys:options:errorHandler:) 方法是非常值得推荐的遍历方式，而假如只是想统计遍历目录下的文件数，SEL(contentsOfDirectoryAtPath:error:)  和  SEL(subpathsOfDirectoryAtPath:error:)  可满足需求。</p>

<p>&nbsp;</p>

<h2>2、文件操作</h2>

<h4>1）创建文件</h4>

<p>API:</p>

<div>
<pre><code>- (BOOL)createFileAtPath:(NSString *)path contents:(NSData *)data attributes:(NSDictionary *)attr;
- (BOOL)writeToFile:(NSString *)path atomically:(BOOL)useAuxiliaryFile;
- (BOOL)writeToURL:(NSURL *)url atomically:(BOOL)atomically; </code></pre>
</div>


<p>&nbsp;
Benchmark结果：<br/>
目标路径文件不存在<br/>
SEL(createFileAtPath: contents: attributes:)<br/>
文件大小：0KB             次数：1000次(1K次)               耗时：4.140s ~ 4.150s<br/>
文件大小：1MB            次数：1000次(1K次)               耗时：28.900s ~ 29.000s</p>

<p>SEL(writeToFile:atomically:)<br/>
atomically:YES    文件大小：0KB                    次数：1000次               耗时：4.150s ~ 4.160s<br/>
atomically:NO      文件大小：0KB                    次数：1000次               耗时：1.010s ~ 1.020s<br/>
atomically:YES    文件大小：1MB                    次数：1000次               耗时：28.900s ~ 29.000s<br/>
atomically:NO      文件大小：1MB                    次数：1000次               耗时：24.600s ~ 25.000s</p>

<p>目标路径文件已存在<br/>
SEL(createFileAtPath: contents: attributes:)<br/>
文件大小：0KB               次数：1000次               耗时：5.540s ~ 5.550s<br/>
文件大小：1MB               次数：1000次               耗时：30.000s ~ 31.000s</p>

<p>SEL(writeToFile:atomically:)<br/>
atomically:YES    文件大小：0KB               次数：1000次               耗时：5.540s ~ 5.550s  <br/>
atomically:NO      文件大小：0KB               次数：1000次               耗时：0.600s ~ 0.610s
atomically:YES    文件大小：1MB               次数：1000次               耗时：30.000s ~ 31.000s<br/>
atomically:NO      文件大小：1MB               次数：1000次               耗时：26.000s ~ 27.000s</p>

<p>从测试来看，创建文件方法SEL(createFileAtPath: contents: attributes: )与SEL(writeToFile:atomically:YES)在效率上没有什么区别，因此估计两者使用了逻辑是一致的；SEL(writeToFile:atomically:NO) 比SEL(writeToFile:atomically:YES)效率高也是合乎情理（因为atomically:YES是先写到一个临时备份文件然后再改名的，以此来保证操作的原子性，防止写数据过程中出现其他错误），但需要注意的是，在创建空文件时，SEL(writeToFile:atomically:NO)效率非常之高，可以考虑在频繁创建空文件的时候使用SEL(writeToFile:atomically:NO)。</p>

<h4>2）拷贝文件</h4>

<p>API:</p>

<div>
<pre><code>- (BOOL)copyItemAtPath:(NSString *)srcPath toPath:(NSString *)dstPath error:(NSError **)error
- (BOOL)copyItemAtURL:(NSURL *)srcURL toURL:(NSURL *)dstURL error:(NSError **)error</code></pre>
</div>


<p>Benchmark结果：<br/>
文件大小：1MB            次数：1000次               耗时：40.800s ~ 42.000s<br/>
文件大小：2MB            次数：1000次               耗时：76.700s ~ 77.000s</p>

<h4>3）移动文件</h4>

<p>API:<br/>
- (BOOL)moveItemAtPath:(NSString <em>)srcPath toPath:(NSString </em>)dstPath error:(NSError **)error<br/>
- (BOOL)moveItemAtURL:(NSURL <em>)srcURL toURL:(NSURL </em>)dstURL error:(NSError **)error</p>

<p>Benchmark结果：<br/>
文件大小：1MB~1GB            次数：1000次               耗时：1.260s ~ 1.580s</p>

<p>&nbsp;</p>

<h4>4）删除文件</h4>

<p>API:</p>

<div>
<pre><code>- (BOOL)removeItemAtPath:(NSString *)path error:(NSError **)error
- (BOOL)removeItemAtURL:(NSURL *)URL error:(NSError **)error</code></pre>
</div>


<p>Benchmark结果：
文件大小：1MB~10M            次数：1000次               耗时：1.560s ~ 1.680s</p>

<h4>5）创建硬链接</h4>

<p>API：</p>

<div>
<pre><code>- (BOOL)linkItemAtPath:(NSString *)srcPath toPath:(NSString *)dstPath error:(NSError **)error 
- (BOOL)linkItemAtURL:(NSURL *)srcURL toURL:(NSURL *)dstURL error:(NSError **)error </code></pre>
</div>


<p>&nbsp;
Benchmark结果：<br/>
目标路径文件不存在                    文件大小：1MB~1G                     次数：1000次               耗时：7.550s ~ 7.600s<br/>
目标路径文件存在（不会覆盖）  文件大小：1MB~1G                     次数：1000次               耗时：7.100s ~ 7.400s</p>

<p>创建文件硬链接在效率上与文件大小无关，而且硬链接所占用的空间极小，因此是拷贝文件非常好的替换方法。需要注意的是，针对目录创建硬链接，会创建一个新的目标目录，然后对源目录里面的文件创建硬链接。为了避免无限递归，在子目录里面创建目录的硬链接是不被允许的。</p>

<h4>6）创建软链接</h4>

<p>API：</p>

<div>
<pre><code>- (BOOL)linkItemAtPath:(NSString *)srcPath toPath:(NSString *)dstPath error:(NSError **)error 
- (BOOL)linkItemAtURL:(NSURL *)srcURL toURL:(NSURL *)dstURL error:(NSError **)error </code></pre>
</div>


<p>&nbsp;
Benchmark结果：<br/>
目标路径文件不存在                    文件大小：1MB~1G                     次数：1000次               耗时：1.360s ~ 1.520s<br/>
目标路径文件存在（不会覆盖）  文件大小：1MB~1G                     次数：1000次               耗时：0.480s ~ 0.530s</p>

<p>文件操作总结：从1) ~ 6)的Benchmark可以看出拷贝文件和写文件一样，需要频繁的IO操作，耗时随着文件增大而拉长；而移动文件、删除文件、创建软硬链则与文件的大小无关，这些都符合我们的预期 。</p>

<p>&nbsp;</p>

<h2>3、文件Handle读写</h2>

<p>将文件读写的Benchmark独立出来是因为文件读写主要测试的是NSFileHandle的性能，而不再是NSFileManager的操作性能测试了。</p>

<h4>1）写文件：</h4>

<p>API：</p>

<div>
<pre><code>- (void)writeData:(NSData *)data;
- (void)synchronizeFile;</code></pre>
</div>


<p>Benchmark结果<br/>
写入数据：512KB/次         次数：2000次          总大小：1GB               耗时：15.400s ~ 15.800s(最后Syn)  /  29.600s ~ 30.000s(每次Syn)<br/>
写入数据：1MB/次             次数：1000次          总大小：1GB               耗时：15.400s ~ 15.800s(最后Syn)  /  24.400s ~ 25.200s(每次Syn)<br/>
写入数据：2MB/次             次数：500次            总大小：1GB               耗时：15.400s ~ 15.800s(最后Syn)  /  21.400s ~ 21.800s(每次Syn)<br/>
写入数据：4MB/次             次数：250次            总大小：1GB               耗时：15.400s ~ 15.800s(最后Syn)  /  20.500s ~ 20.800s(每次Syn)<br/>
写入数据：8MB/次             次数：125次            总大小：1GB               耗时：15.400s ~ 15.800s(最后Syn)  /  20.300s ~ 20.600s(每次Syn)</p>

<p>ps：Syn表示调用synchronizeFile来flush缓存
从上面的Benchmark可以看到，对于一定量的数据来说，缓冲区到硬盘的IO操作是由系统控制的，因此只在最后Syn的情况下，各种大小的字节数据writeData写入缓冲区使用的时间几乎是一样的，而每次writeData之后立刻调用Syn，则会让IO的操作增加，导致耗时的增加。所以，假如数据是可恢复的，那建议在写完数据所有数据之后再调用Syn。IO的写入效率为65M/s左右。</p>

<h4>2）读文件：</h4>

<p>API：</p>

<div>
<pre><code>- (NSData *)readDataToEndOfFile; - (NSData *)readDataOfLength:(NSUInteger)length;</code></pre>
</div>


<p>&nbsp;
Benchmark结果<br/>
读取数据：1KB/次              次数：1024<sup>2</sup>次       总大小：1GB               耗时：32.200s ~ 32.500s <br/>
读取数据：126KB/次          次数：4096次          总大小：1GB               耗时：11.100s ~ 11.300s<br/>
读取数据：256KB/次          次数：4096次          总大小：1GB               耗时：10.800s ~ 11.000s<br/>
读取数据：512KB/次          次数：2048次          总大小：1GB               耗时：10.300s ~ 10.600s<br/>
读取数据：1MB/次             次数：1024次          总大小：1GB               耗时：10.600s ~ 10.800s<br/>
读取数据：2MB/次             次数：512次            总大小：1GB               耗时：10.600s ~ 10.800s<br/>
读取数据：4MB/次             次数：256次            总大小：1GB               耗时：10.600s ~ 10.800s<br/>
读取数据：8MB/次             次数：128次            总大小：1GB               耗时：10.000s ~ 10.200s</p>

<p>从上面的benchmark发现，读512KB到8M各种大小规格数据块，效率上差别不大（相对于IO，遍历2000次与125次的差别微乎其微，因此忽略），但可看到从256KB逐步减小每次读取的数据块开始，耗时开始增加，当每次读取1KB的时候，耗时拉长到3倍，原因是没有充分利用IO缓冲区，增加了IO操作次数导致的；在现有的系统环境下，单次读取数据再继续往上测试的意义不大（单次读取16M、32M占用内存过大）。由测试得出，在现有测试环境下，每次读取数据块合理大小为512KB~4MB，IO读取效率为 100M/s 左右。</p>

<blockquote><p>引自Apple 文档：https://developer.apple.com/library/ios/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/PerformanceTips/PerformanceTips.html
Choose an appropriate read buffer size. When reading data from the disk to a local buffer, the buffer size you choose can have a dramatic effect on the speed of the operation. If you are working with relatively large files, it does not make sense to allocate a 1K buffer to read and process the data in small chunks. Instead, create a larger buffer (say 128K to 256K in size) and read much or all of the data into memory before processing it. The same rules apply for writing data to the disk: write data as sequentially as you can using a single file-system call.</p></blockquote>

<h4>2）Seek文件：</h4>

<p>API：</p>

<div>
<pre><code>- (unsigned long long)seekToEndOfFile; - (void)seekToFileOffset:(unsigned long long)offset;</code></pre>
</div>


<p>Benchmark结果(生成随机数随机seek)：<br/>
文件大小：1GB              次数：1,000,000次            耗时：3.000s ~ 3.200s</p>

<p>Seek文件是一个非常高效的操作，做一次seek操作，相当于遍历一个10个元素的数组。</p>

<p>总结：<br/>
以上的Benchmark，由于受限于测试环境，未必准确，而且在不同的设备上体现也不一样，其主要的目的是，让我们对IO操作的性能有个数据图像上的理解。当然，此次Benchmark调用的API都是比较cocoa上层的API，假如使用Linux的IO库来进行操作，相信效率会有不同的展现，这个就留待后续发掘吧。</p>

<p>PS：很多IO操作的API中，都提供了path(NSString)和url(NSURL)两种参数方式，我们一直习惯使用path的方式，但官方文档提供的指导是推荐使用NSURL：</p>

<blockquote><p>引自Apple 文档：https://developer.apple.com/library/ios/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/PerformanceTips/PerformanceTips.html
When deciding which routines to call, choose ones that let you specify paths using NSURL objects over those that specify paths using strings. Most of the URL-based routines were introduced in OS X 10.6 and later and were designed from the beginning to take advantage of technologies like Grand Central Dispatch. This gives your code an immediate advantage on multicore computers while not requiring you to do much work.
Reuse path objects. If you take the time to create an NSURL for a file, reuse that object as much as you can rather than create it each time you need it. Locating files and building URLs or pathname information takes time and can be expensive. Reusing the objects created from those operations saves time and minimizes your app’s interactions with the file system.</p></blockquote>

<p>更多iOS文件系统相关信息，请查看：File System Programming Guide</p>

<p>15 Jan 2014</p>

]]></content:encoded>
    </item>
    
    <item>
      <title>面向接口编程之提炼接口（Objective-C ）</title>
      <link href="http://jaminzzhang.github.com/2013/12/31/Oriented-Protocol/"/>
      <pubDate>2013-12-31T00:00:00+08:00</pubDate>
      <author>jaminzzhang</author>
      <guid>http://jaminzzhang.github.com/2013/12/31/Oriented-Protocol</guid>
      <content:encoded><![CDATA[<h2>面向接口编程之提炼接口（Objective-C ）</h2>

<span>一般，我们所理解的面向接口编程，是为了规范接口，在编码前先写好不同模块间的接口，便于不同模块间的合作。但其实这只是接口的一部分作用，本文所要描述的是，是另外一种面向接口的思想：提炼接口（Extract Interface 引自《重构 改善既有代码的设计》P341）。</span>

<span>Objective-C是一个单继承(single inheritance)的面向对象语言，这里的单继承指的是类(Interface)的单继承，一个类只能且必须由一个父类所派生，所有的类都是从NSObject派生的。相对于类而言，接口(protocol)却给了我们更多的自由，接口可以继承自多个接口，可以完全不继承自任何接口。 对于Objective-C，java和C#这种类单继承的面向对象高级语言来说，类好比就是人类，一个个体人只能由一对父母生育；而接口就像身份，人在不同的场合总有不同的身份。一名屌丝码农，可能是一个女孩多情浪漫的男朋友，也可能是一个男孩一起LOL的好基友。不同的身份适应不同的场合，假如刚才的身份调换，那…</span>
<div class="km_insert_code">
<pre><code>@<span class="class"><span class="keyword">protocol</span> <span class="id">Protocol1</span></span>

- (<span class="keyword">void</span>)test;

@<span class="keyword">end</span>

@<span class="class"><span class="keyword">protocol</span> <span class="id">Protocol2</span> &lt;<span class="id">NSObject</span>&gt;</span>

- (<span class="keyword">void</span>)test;

@<span class="keyword">end</span>

@<span class="class"><span class="keyword">protocol</span> <span class="id">Protocol3</span> &lt;<span class="id">Protocol1</span>, <span class="id">Protocol2</span>&gt;</span>

- (<span class="keyword">void</span>)subTest;

@<span class="keyword">end</span>

@<span class="class"><span class="keyword">interface</span> <span class="id">TestProtocol</span> : <span class="id">NSObject</span> &lt;<span class="id">Protocol3</span>&gt;</span>

@<span class="keyword">end</span>
</code></pre>
</div>
&nbsp;

<span>因此，本文所讲的提炼接口，即规范在不同场合下的不同身份特征接口，由类去实现这些接口来适应不同的场合。</span>

<span>下面，以我们最近项目遇到的问题来讲述接口在我们ON项目中的运用。该项目中需要实现一个展示文件列表，文件下载、展示、保存、删除等一系列操作的功能，这是个非常常见的功能，如微博，信息等都有类似展示列表，列表条目下载、展示、保存和删除等。功能So Easy，时间紧迫，我们直接得出V1.0的版本：</span>
<h3>1. V1.0版本</h3>
<p style="text-align: center;"><a href="/assets/images/2013-12-31-Oriented-Protocol/1.png"><img class="aligncenter size-medium wp-image-317" alt="1" src="/assets/asset_path images/2013-12-31-Oriented-Protocol/1.png" width="300" height="216" /></a></p>
<p style="text-align: center;"><em>（架构示意图1）</em></p>
<span>Class: ONFile，文件Model类，承载文件信息，其对象是文件操作的实体。</span>
<div class="km_insert_code">
<pre><code>@<span class="class"><span class="keyword">interface</span> <span class="id">ONFile</span> : <span class="id">NSObject</span></span>

@<span class="keyword">property</span> (<span class="keyword">nonatomic</span>, copy) <span class="built_in">NSString</span> *  fileId;
@<span class="keyword">property</span> (<span class="keyword">nonatomic</span>, copy) <span class="built_in">NSString</span> *  name;
@<span class="keyword">property</span> (<span class="keyword">nonatomic</span>, copy) <span class="built_in">NSString</span> *  md5;
@<span class="keyword">property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *  localPath;

@<span class="keyword">end</span></code></pre>
</div>
&nbsp;

<span>Class: ONFileManager，文件管理类，一般使用单例对象sharedManager来管理文件。</span>
<div class="km_insert_code">
<pre><code>@<span class="class"><span class="keyword">interface</span> <span class="id">ONFileManager</span> : <span class="id">NSObject</span></span>

+ (ONFileManager *)sharedManager;

<span class="comment">//文件操作</span>
- ( <span class="built_in">NSArray</span> *)fetchFileList;
- (<span class="built_in">BOOL</span>)deleteFile:(ONFile *)file;
- (<span class="built_in">BOOL</span>)downloadFile:(ONFile *)file;
- (<span class="built_in">BOOL</span>)saveFile:(ONFile *)file;

@<span class="keyword">end</span></code></pre>
</div>
&nbsp;

<span>Class: ONFileListViewController，文件列表展示类，展示文件列表。</span>
<div class="km_insert_code">
<pre><code>@<span class="class"><span class="keyword">interface</span> <span class="id">ONFileListViewController</span> : <span class="id">UIViewController</span></span>

<span class="comment">//加载文件列表</span>
- (<span class="keyword">void</span>)reloadFileList;

@<span class="keyword">end</span></code></pre>
</div>
&nbsp;

<span>Class: ONFileViewController，文件内容展示类，展示文件内容，以及进行文件操作的类。</span>
<div class="km_insert_code">
<pre><code>@<span class="class"><span class="keyword">interface</span> <span class="id">ONFileViewController</span> : <span class="id">UIViewController</span></span>

@<span class="keyword">property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) ONFile * openedFile;

<span class="comment">//文件操作</span>
- (<span class="keyword">void</span>)loadFile:(ONFile *)file;
- (<span class="built_in">BOOL</span>)deleteFile;
- (<span class="built_in">BOOL</span>)saveFile;

@<span class="keyword">end</span></code></pre>
</div>
<span>功能简单，结构清晰，编码一气呵成，几乎没有费什么力气就完成了该功能。</span>
<h3>2. V1.1版本</h3>
<span>假如你也觉得这样就完了，那你也像当年的我一样——Too young too simple！虐你千万遍的需求变更：接入其他服务A的文件，功能类似，展示有细微区别。这难不倒撸主，解决的方案是：因为服务A的文件系统的信息与ONFile基本一致，所以维持当前的结构不变，引入的服务A的文件继承自类ONFile，派生出子类ONAFile，这个时候，架构示意图看起来如下：</span>

<a href="/assets/images/2013-12-31-Oriented-Protocol/2.png"><img class="aligncenter size-medium wp-image-318" alt="2" src="{/assets/images/2013-12-31-Oriented-Protocol/2.png" width="300" height="215" /></a>
<p style="text-align: center;"><em style="line-height: 2em;">（架构示意图2）</em></p>
<span>代码中假如了少量的判断分支语句，看起来有点难看，但尚可接受。</span>
<h3>3. V1.2版本 ~ V1.X版本</h3>
<span>很明显，当有了第一次需求变更，我们很快会变淹没在需求的海洋里。</span>
<span>V1.2，为了差异化，各种类型的文件展示方式不一样；</span>
<span>V1.3，接入服务B的文件系统（ONBFile），并不如服务A幸运，服务B的文件信息与ONFile的信息差别较大，操作和列表展示也不太一致，但文件内容展示是一致的；</span>
<span>V1.4，支持其他App OpenIn文件到我们的App</span>
<span>…</span>
<span>很熟悉的场面是不是？几乎所有的程序员都会遇到过当前的系统架构完全无法满足需求的野蛮扩充，所以，我们需要接口。</span>
<h3>4. 高可扩展性的V2.0版本</h3>
<span>当你发现你所要支持的信息展示之复杂，已经超出了你当初设计可承载的时候，你是会继续沿用就有的设计，加入更多的判断分支处理相同功能中的部分差异，复制粘贴更多的相同的处理代码来处理差异信息中的部分相同功能？亦或者是，重构你的设计，让之前未考虑清除的可扩展性回到你的设计中。</span>

<span>所以，我们开始了接口编程：</span>
<p style="text-align: center;"><a href="/assets/images/2013-12-31-Oriented-Protocol/3.png"><img class="aligncenter size-medium wp-image-319" alt="3" src="/assets/images/2013-12-31-Oriented-Protocol/3.png" width="258" height="300" /></a></p>
<p style="text-align: center;"><em>（架构示意图3）</em></p>
<span>接口化之后，有以下几个优点：</span>
<span>1）<b>可扩展性</b>：可扩展性主要体现在以下两个方面：</span>
<span>     a) 从架构图来看，貌似类增加了，但实际上增强了各模块的解耦性，能够非常方便地增减模块，使用接口来替代糟糕的判断语句；</span>
<span>         如现在需要接入服务C的文件系统，而信息展示上与ONBFile一致，那么只需要以下三步：</span>
<span>          I.   在数据层创建ONCFileInfo，ONCFile实现&lt;ONFileInfo&gt;的接口；</span>

<span>逻辑层数据接口：</span>
<div class="km_insert_code">
<pre><code>@<span class="class"><span class="keyword">protocol</span> <span class="id">ONFileInfo</span> &lt;<span class="id">NSObject</span>&gt;</span>

- (<span class="built_in">NSString</span> *)fileId;
- (<span class="built_in">NSString</span> *)name;
- (<span class="built_in">NSString</span> *)md5;

@<span class="keyword">end</span></code></pre>
</div>
&nbsp;
<div class="km_insert_code">
<pre><code>@<span class="class"><span class="keyword">interface</span> <span class="id">ONCFileInfo</span>()&lt;<span class="id">ONFileInfo</span>&gt;</span>

@<span class="keyword">property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> * fileId;
@<span class="keyword">property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> * name;
@<span class="keyword">property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> * md5;

- (<span class="keyword">id</span>)initWithFileId:(<span class="built_in">NSString</span> *)fileId;

@<span class="keyword">end</span>
</code></pre>
</div>
<em id="__mceDel">          </em> II.  在逻辑层创建ONCFileManager，ONCFileManager实现ONCFileInfo支持的一系列操作，并在ONAllFileManager分发ONCFile的操作到ONCFileManager;（如架构图所示）

III. 在接口层，创建类ONUICFile，实现ONUIBFile的接口，即可直接复用ONUIBFile的IU组件进行展示。

UI层的数据接口
<div class="km_insert_code">
<pre><code>@<span class="class"><span class="keyword">protocol</span> <span class="id">ONUIFile</span> &lt;<span class="id">NSObject</span>&gt;</span>

- (<span class="built_in">NSString</span> *)fileId;
- (<span class="built_in">NSString</span> *)name;
- (<span class="built_in">UIImage</span> *)thumb;

@<span class="keyword">end</span>
</code></pre>
</div>
<div class="km_insert_code">
<pre><code>@<span class="class"><span class="keyword">protocol</span> <span class="id">ONUIBFile</span> &lt;<span class="id">ONUIFile</span>&gt;</span>

- (<span class="built_in">NSString</span> *)formatedTime;

@<span class="keyword">end</span>
</code></pre>
</div>
<div class="km_insert_code">
<pre><code>@<span class="class"><span class="keyword">interface</span> <span class="id">ONUICFile</span> : <span class="id">NSObject</span> &lt;<span class="id">ONUIBFile</span>&gt;</span>

@<span class="keyword">property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> * fileId;
@<span class="keyword">property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> * name;
@<span class="keyword">property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> * formatedTimeStr;

@<span class="keyword">end</span>
</code></pre>
</div>
<em> PS：不一定需要创建类ONUICFile，假如不想创建类ONUICFile，只需要让接口层返回fileInfo的对象，但对于UI层接口来说，只是访问ONUIFile接口</em>

<span>UI层的展示</span>
<div class="km_insert_code">
<pre><code>- (<span class="keyword">void</span>)updateWithFile:(<span class="keyword">id</span>&lt;ONUIBFile&gt;)file
{
    <span class="keyword">self</span><span class="variable">.imageView</span><span class="variable">.image</span> = [file thumb];
    <span class="keyword">self</span><span class="variable">.nameLabel</span><span class="variable">.text</span> = [file name];
    <span class="keyword">self</span><span class="variable">.detailLabel</span><span class="variable">.text</span> = [file formatedTimeStr];
}</code></pre>
</div>
<span>     b) 而且由于接口的多继承特性，能够很好的实现差异化的需求。</span>
<span>     如在某个整体的列表中，ONFile、ONAFile、ONBFile要统一样式展示，而在服务B的文件系统时，ONBFile需要特殊展示，使用接口，各个展示模块只需要制定自己的接口，由需要展示的数据来实现这些接口即可。</span>

<span>2）<b>可复用性</b>：但实现完全不依赖于某一个类，只是依赖于接口，将接口组合复用成本明显比将类组合复用要低很多。</span>

<span>3）<b>保证数据安全</b>：之前的实现是逻辑控制层、数据层和视图层都用同一个数据，数据很容易在某个环节被修改，就会导致数据被污染；接口化之后，UI层只获取到接口，可再接口这一层保证数据安全。</span>

<span>当然，接口并非是万能的，接口非常适用于某个类或者实体需要在不同的环境中扮演不同的身份或角色，特别是对于Objective-C这中类只能单继承的语言。本文中所要阐述的面向接口的思想，不只是针对Objective-C这一种语言，其思想在各种语言中都是共通的。</span>

<p>31 Dec 2013</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>《你一定爱读的极简欧洲史》</title>
      <link href="http://jaminzzhang.github.com/2013/10/21/History-Of-EU/"/>
      <pubDate>2013-10-21T00:00:00+08:00</pubDate>
      <author>jaminzzhang</author>
      <guid>http://jaminzzhang.github.com/2013/10/21/History-Of-EU</guid>
      <content:encoded><![CDATA[<h2>《你一定爱读的极简欧洲史》</h2>




<p>终于在kindle上看完了这一本《你一定爱读的极简欧洲史》，确实是极“简”的欧洲史。“简”并非“简单”，而是“简练”，John Hirst对欧洲史有着非常系统的总结提炼，高屋建瓴，从欧洲文明的起源——希腊文明——出发，分析各种历史事件和元素间的因果逻辑联系，让读者对欧洲历史文明的来龙去脉有了系统清晰的认识，而不像一般的历史书，只是简单的历史事件称述，无视其之间的联系。

无意对书本作一次照本宣科，建议对欧洲感兴趣的同学都从这本极简欧洲史开始，了解整个欧洲文明的发展。在阅读过程中，做了些笔记：

1、欧洲历史时间线
<a href="http://www.oncenote.com/wp-content/uploads/2013/10/Snip20131021_2.png"><img class="aligncenter size-medium wp-image-273" alt="欧洲历史" src="http://www.oncenote.com/wp-content/uploads/2013/10/Snip20131021_2-300x269.png" width="300" height="269" /></a>

2、借由理性思索出整个自然体系的运作，又能用数学精确表达，当然就可以利用理性更上一层楼。文明可以把这份理性用于人来生活，让他得到脱胎换骨的改善，这份以理性为尊的渴望，就成了启蒙运动的驱动力。

3、想象一群人，被囚禁于一个幽暗洞穴之中，而且全部被锁链绑住手脚。他们背对高墙镇日坐着，看不到背后，只能面对另一面的穴壁。洞穴外头有一条路，路的尽头有一个大火炬，路上若有其他人、动物和车辆经过，火炬就会将这些东西的影子投射在他们面对的穴壁上。这些穴居人看到的唯一事物就是这些影像；他们替阴影命名、品头论足；针对它们推理辩论；他们相信，这些影子是世间真实的存在。
后来，其中一人意外被解开锁链，从山洞走到露天处。一开始，强烈的光线照得他睁不开眼，等他看到阳光下五彩缤纷、美好的立体世界，不禁又惊又疑。可是，他说，在山洞里，我们以为……
没错，当你身在洞里，你不可能看真相。
——柏拉图

4、英国“光荣革命”——《权利法案》
个人权利：
<ul>
    <li><span style="line-height: 1.714285714; font-size: 1rem;">人民有向国王请愿的权利（教会人士曾向詹姆斯二世请愿，希望国王更改他的宗教政策，结果遭到詹姆斯惩罚）。</span></li>
    <li><span style="line-height: 1.714285714; font-size: 1rem;">人民不得被科以过高的保释金和罚金。</span></li>
    <li><span style="line-height: 1.714285714; font-size: 1rem;">人民有不遭受残酷与非常惩罚的自由。</span></li>
    <li><span style="line-height: 1.714285714; font-size: 1rem;">新教徒有携带武器的权利。</span></li>
    <li><span style="line-height: 1.714285714; font-size: 1rem;">陪审团成员不得由国王选派。</span></li>
</ul>
5、《人类与人民权利宣言》（ Declaration   of   the Rights   of   Man   and   of   the   Citizen）
<ul>
    <li><span style="line-height: 1.714285714; font-size: 1rem;">人类与生俱来地拥有自由与平等的权利，并且始终如此。</span></li>
    <li><span style="line-height: 1.714285714; font-size: 1rem;">这些人权包括自由、财产、安全、反抗压迫的权利。</span></li>
    <li><span style="line-height: 1.714285714; font-size: 1rem;">整个主权的本源乃寄托于全民。</span></li>
    <li><span style="line-height: 1.714285714; font-size: 1rem;">所谓自由，意指有权从事一切无害于他人的行为。</span></li>
    <li><span style="line-height: 1.714285714; font-size: 1rem;">不管是亲身或透过代表为之，每一位公民皆有权参与法律的制定。</span></li>
    <li><span style="line-height: 1.714285714; font-size: 1rem;">法律只应规定确实必要的刑罚；</span><span style="line-height: 1.714285714; font-size: 1rem;">任何人均不得被控告、逮捕与拘留，除非在法律规定的情况下并按照法律程序为之。</span></li>
    <li><span style="line-height: 1.714285714; font-size: 1rem;">任何人不应因其意见，包括其宗教观点而遭到骚扰。</span></li>
    <li><span style="line-height: 1.714285714; font-size: 1rem;">每一位公民都有发表言论、写文章与出版的自由，但若在法律所规定的情况下滥用了这项自由，仍应负担责任。</span></li>
    <li><span style="line-height: 1.714285714; font-size: 1rem;">权力的分立未能得到确立的宪法根本不能称为宪法。</span></li>
</ul></p>




<p>21 Oct 2013</p>

]]></content:encoded>
    </item>
    
    <item>
      <title>iOS 7(写在WWDC 2013前 )</title>
      <link href="http://jaminzzhang.github.com/2013/06/09/iOS7/"/>
      <pubDate>2013-06-09T00:00:00+08:00</pubDate>
      <author>jaminzzhang</author>
      <guid>http://jaminzzhang.github.com/2013/06/09/iOS7</guid>
      <content:encoded><![CDATA[<h2>iOS 7(写在WWDC 2013前 )</h2>




<p><p><em>其实这篇文章一直在酝酿，总感觉自己想的可能都会是错的，但做个马后炮更是我可耻的事，所以，还是随便聊聊心中的大概，其实还会有些没有写出来，怕真的贻笑大方罢。</em></p>

<p><a href="http://www.oncenote.com/wp-content/uploads/2013/05/QQ20130531-1@2x.png"><img class="alignnone size-medium wp-image-216 aligncenter" alt="QQ20130531-1@2x" src="http://www.oncenote.com/wp-content/uploads/2013/05/QQ20130531-1@2x-300x216.png" width="300" height="216" /></a></p>

<p>再过两天，Apple 的 WWDC 2013就会在旧金山召开，关于iOS 7和 OSX 10.9的传言也越来越盛嚣尘上，作为一个两年多的iOS开发者，从一开始对WWDC一无所知，到慢慢地关心整个系统生态的发展，希望掌握最前沿的技术，WWDC是最高效，最标准、最具权威性的资料。那在iOS 7发布之前，作为一个开发者，我心目中的iOS 7是什么样的呢？除了媒体上每天爆料的什么UI设计扁平化，通知中心加入widgets小开关等，我希望从一个开发者的角度，设想下iOS 7：
<h3>1、iPhone、iPad（Universal）完美整合:</h3>
<blockquote>
<p style="text-align: left;">“We always strive to create the very best display. Some customers value large screen size. Others value other factors such as resolution, color quality, white balance, reflectivity, power consumption, compatibility of apps, portability. Our competitors have made some significant tradeoffs in many of these areas to ship a larger display. We would not ship a larger display iPhone while these tradeoffs exist.”</p>
<p style="text-align: right;">——Tim Cook</p>
</blockquote>
库克说过，苹果不会在没有解决大屏显示效果和操作体验之前推出大屏幕手机。我想，iOS7该是时候了。在XCode4.4发布之后，我们会发现，不管是iPad程序还是iPhone程序，都可以选择iOS 6.0以上的iPad或者是iPhone来运行，这其实就是整合的信号。就像从iPhone4 到iPhone5，从960x640到1136x640，变宽对于iOS的坐标体系来说，完全没有任何的问题。整合了之后，iPad、iPhone、iPod应用间几乎不存在差别。当然，大屏同样会带来新的交互体验，手势，新的交互组件，比如前进返回使用左右可触摸的边框物理按键，相信Apple会处理的更卓越。
<h3>2、强大的iCloud，整合更加强大的分享服务:</h3>
分享的东西才会生命力和价值。虽然现在iCloud还没有露出丝毫改革的迹象，但相信苹果不会只是把iCloud当做一个廉价的存储介质。体现其生命力的地方就是与分享整合。现有的分享服务(UIActivityViewController)都过于简单，只能分享图片和文字，还有其他媒体文件其实可以直接从iCloud中走出去。
<h3>3、AirDrop &amp; AirPlay:</h3>
任何一个第一次使用AirDrop或AirPlay，而又曾经被windows共享服务折磨过的人，都会震惊于AirDrop/AirPlay的完全无设置傻瓜式操作和出来的效果。从技术上来说，AirDrop和AirPlay应该是类似的东西，都是通过WIFI搭建特定热点，用于数据传输，只是对于AirPlay来说，iPhone/iPad上只有数据发送设备，而没有接受设备。两者可能从表现形式上来说不会整合，但相信不久，一台iPhone/iPad，就可以将媒体或者文件共享或者发送到无数的iPhone/iPad设备上，这并不太遥远。
<h3>4、新的UI组件:</h3>
每次大的版本修改，iOS都会带来新的UI组件，比如iOS5的<a title="UIStepper" href="http://developer.apple.com/library/ios/#documentation/uikit/reference/UIStepper_Class/Reference/Reference.html" target="_blank">UIStepper</a>和<a title="UIPageViewController" href="https://developer.apple.com/library/ios/#documentation/UIKit/Reference/UIPageViewControllerClassReferenceClassRef/UIPageViewControllerClassReference.html#//apple_ref/occ/cl/UIPageViewController" target="_blank">UIPageViewController</a>，iOS6的<a title="UICollectionView" href="https://developer.apple.com/library/ios/#documentation/UIKit/Reference/UICollectionView_class/Reference/Reference.html#//apple_ref/occ/cl/UICollectionView" target="_blank">UICollectionView</a>和<a title="UIRefreshControl" href="https://developer.apple.com/library/ios/#documentation/UIKit/Reference/UIRefreshControl_class/Reference/Reference.html#//apple_ref/occ/cl/UIRefreshControl" target="_blank">UIRefreshControl</a>等，这些都是当时最流行的UI控件。因此，我们有理由相信iOS7也会给我们一个当前流行的通用控件，比如侧滑抽屉控件，比如有折叠打开的TableView，比如更好看的悬浮操作条。
<h3>5、文件预览能力:</h3>
从iOS4开始，每个版本的升级都会带来文件预览效果大的提升。相信iOS7不会让人失望。既然是已成惯例，还有什么好说的呢？现有的UIPreviewController的功能已经足够强大，那我们还应该期待什么？我们当然还有足够的期待，如更强大的文档页面滚动方式:翻页或左右滑动；如支持通用css排版等。</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>----------------------------------------------------2013.6.11----------------------------------------------------------</p>

<p>iOS 7终于发布，相较于OSX的惊艳，新的iOS UI改版对我来说显得有些惊悚，到现在都难以接受，其实扁平化设计一早已经风传，只是不曾想到竟扁平成Android样！这些都不是重点，重点是从视频和图片上来看，色调太过怪异模糊（对于我来说），感觉可能会比较符合欧美人的审美。一切等上手之后再说吧。</p>

<p>&nbsp;</p>

<p>上面预想的几条基本都验证了，iCloud增强超出我的预期，看来Apple在云端布局还是蛮有雄心的；而AirDrop&amp;AirPlay不过是技术上的必然发展应用而已。小赞下自己。从网上获取到Xcode设置 iOS 7的图标为120x120，比原本的114x114增加了6个像素，为图标的扁平化而减小图标间的间距也是合理的解释，不过我认为这或许会略显有些拥挤，我更相信未来的iPhone会往大屏幕发展，分辨率可能就是现在iPad的分辨率1024x768。</p>

<p>&nbsp;</p>

<p>现在只能期待秋季发布会，希望iPhone能够有新的不一样的感觉。最后想说：革自己的命没错，但步子迈得太大了会扯到蛋的。
/p></p>

<p><p>09 Jun 2013</p></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>谈谈iPhone和Android</title>
      <link href="http://jaminzzhang.github.com/2013/05/12/iPhone-VS-Android/"/>
      <pubDate>2013-05-12T00:00:00+08:00</pubDate>
      <author>jaminzzhang</author>
      <guid>http://jaminzzhang.github.com/2013/05/12/iPhone-VS-Android</guid>
      <content:encoded><![CDATA[<h2>谈谈iPhone和Android</h2>




<p>在合肥呆了一年，在深圳又一年，iPhone的合约已经到期，号码还是合肥的号，想着不会再回到合肥了，决定换个号码。选择，继续用iPhone，还是尝试Android？

&nbsp;

iPhone，目前为止，人类最出色最颠覆式的手机。看回曾经iPhone的发布视频，才能更深刻地感受到这种颠覆（后续会整理下，写个相关的文章）。iPhone 5的发布，没有太多的出乎意料，遭受了像当初iPhone 4刚发布一样的质疑，可iPhone 4用自己的跨越式的创新，赢得了用户的心。时至今日，iPhone 4的设计在我看来，依然走在设计的前沿，虽然已经烂大街了。然而iPhone 5销量从发布初的一时火爆到半年后日渐惨淡，苹果是否真的在一步步远离用户？

&nbsp;

Android，智能手机的“王者”。这个“王者”的称谓其实并不太合适，虽然其全球份额达到了52%以上，可苹果占据了整个手机领域营收的70%，所以iPhone更具天生的王者霸气。Android生态混乱，系统分裂严重，安全性不足都是大家知道的问题，最重要的是，即使Android手机的硬件比iPhone高一倍，其体验依旧无法与iPhone相媲美。

&nbsp;

最终，我还是选择了去尝试体验Android——SAMSUNG Galaxy SIII（Seveny的爱机），然后，和很多的Android用户一样，刷机开始！一个移动开发软件工程师，即使是非Android领域的，对于刷机这件事来说，通常都有着足够的优越感。所以，我只不过是草草扫了下论坛里面的指南，然后就开始下载好评度比较高的Android系统——MIUI，安装好之后，按照着操作，一步一步......好吧，真的就只是两步，安装驱动失败。这个难不倒我。先到三星官网，没有；下载驱动精灵，这次可以了，安装三个驱动；重新打开MIUI刷机，提示驱动版本过低.....用官方管理软件升级，成功，网络锁......ROOT，解锁不成功，刷回4.0.4，再刷.....刷......用了一个周末终于搞定，期间细读了机锋网、MIUI论坛里面的多张帖子，还有寻求了搞Android室友的帮助，切实感受到了Android分裂的状况，老是会问，为什么其他人可以，我不可以。

&nbsp;

痛苦的刷机经历暂时告一段落，几天下来，慢慢熟悉了这个4.8英寸的“巨物”。 总体而言，两个系统各有优缺点，细节无需多说，网上已经大把了。说说个人这几天下来的一些最直接的感受：

&nbsp;
<ol>
    <li><strong><span style="line-height: 1.714285714; font-size: 1rem;">屏幕。</span></strong><span style="line-height: 1.714285714; font-size: 1rem;">好吧，不能免俗，屏幕是最直接的冲击。720P的Super AMOLED屏在我眼前就像是像素复古风，最直接的感受就是字体发虚，图片边缘粗糙。被iPhone retina屏惯了两年，十天下来，还是没办法习惯Super AMOLED屏艳丽明亮的成像效果。个人认为iPhone的屏幕成像更自然柔和。当然，Galaxy S4 的dpi已经达到了440 DPI，可惜像素还是使用坑爹的Pentile排列，相信效果会大打折扣，等真机出来再看看。等等，人家S3是4.8寸大屏诶！好吧，我尝试在上面播放视频，感觉还是太小了，iPad才适合；至于阅读，当然大屏会比较舒服，可发虚的字实在让人眼晃。</span></li>
    <li><strong><span style="line-height: 1.714285714; font-size: 1rem;">速度。</span></strong><span style="line-height: 1.714285714; font-size: 1rem;">平心而讲，同代机型相比，S3与iPhone4s在速度上几乎没什么差距，四核的S3确实比其他一般的Android机型快上不少，但内存管理是Android机的大缺陷，打开多应用，S3就开始热的发烫，而且电量会唰唰往下掉。虽然速度上不相上下，可Android的动画对比iOS机还是有些差距，不够自然。</span></li>
    <li><strong>返回键。</strong>iPhone 5发布之后，界面返回立马成了iOS应用不得不面对的问题，按照iOS的UI设计规范，界面的POP一般使用顶部导航栏左边的返回按钮，可其3.49英寸高的屏幕，让右手持有者点击返回键变得非常困难，所以现在很多应用都开始求变，最近新版的腾讯微博iOS去掉了很多用户喜欢的滑动撕纸出现操作按钮的效果，而统一改成向右滑动返回的操作，就是为了在iPhone5上获得更好的操作体验。而Android上的返回键是Android机最常使用的按键，没有之一。十天下来，使用iPhone时，我已经开始习惯去点击右下角的返回键。Android的返回键虽然很好用，但在S3上非常容易误点，而且相比于iPhone的一个Home键，Android上程序切换的路径变得多了很多，没有iOS来的简单。比如在Android上打个电话，切换出去找记事本，然后找联系人，再不经意的时候点击返回键，会回到打电话的界面，让人摸不着头脑。个人认为，两个系统的返回键都不是最优的解，个人更希望那种可以前进后推的按键，其实可以考虑边框按键，或者类似黑莓的滚轮样的界面切换按键。期待出现新的交互方式。</li>
    <li><strong>市场。</strong>市场永远是不得不说的话题，开始使用S3时，我以为我可以轻易的抛开iOS，可惜Android系统的市场是Android系统饱受多年的痛，不止分散，而且各类应用商城林立，你不知道你在iOS上玩得很好玩的应用在这些商城上能否找到，你不知道哪个商城里面的应用是最新的，也不知道该到哪里去更新你在用的应用，最让人没办法忍受的是，你不知道你在这些商城里面的应用是不是安全的。而且不得不吐槽Android各类应用商城都设计的非常难看，而且推荐算法基本都不靠谱。</li>
</ol>
写了这么多，说了Android很多的坏话，希望Android粉不要喷我，系统上各有爱好很正常。使用Android会让你有玩机的快感，因为Android的可定制化能力更强，可惜我已经过了喜欢折腾各种系统，各种皮肤主题的年龄；iOS可以给人更优质的体验，应用生态更健康，也更多精美的应用。当然，作为一个用户，很开心能够看到两个伟大的系统一起竞争前进，可预见未来的系统会更符合大众用户的体验，不远的将来，移动互联网已经不只是手机，也许手机将会消失，成为人身体的一部分，不在局限于手持。期待另一个乔布斯，另一个伟大的颠覆。</p>




<p>12 May 2013</p>

]]></content:encoded>
    </item>
    
    <item>
      <title>为你，千千万万遍——《追风筝的人(The Kite Runner)》</title>
      <link href="http://jaminzzhang.github.com/2013/04/11/%3CThe-kite-Runner%3E/"/>
      <pubDate>2013-04-11T00:00:00+08:00</pubDate>
      <author>jaminzzhang</author>
      <guid>http://jaminzzhang.github.com/2013/04/11/<The-kite-Runner></guid>
      <content:encoded><![CDATA[<h2>为你，千千万万遍——《追风筝的人(The Kite Runner)》</h2>


<p>昨晚在跟Blank以及几个球友聚餐后，没带电脑回来了，然后花了两个小时把《追风筝的人》剩下的1/3看完了，曾经那种看书酣畅淋漓的感觉又布满每个神经。收书，关灯，合眼，脑海随即浮起一个长着中国娃娃脸的男孩，他踩着松软的草地飞奔，清新的泥土随着高高扬起的脚丫四溅，他回过头："为你，千千万万遍！"。</p>

<p>The Kite Runner，即是那个长着中国娃娃脸的男孩——哈桑，也是书中的主人公——阿米尔。哈桑为了阿米尔追风筝，这是真挚的友情，“为你，千千万万遍！”，即使被伤害，被背叛，依旧为你。阿米尔为了哈桑的儿子——索拉博追风筝，“为你，千千万万遍！”，不仅仅只是为了向哈桑救赎，还有浓浓的亲情。作者卡勒德·胡塞尼（Khaled Hosseini）以自己的故乡阿富汗作为背景，在那个从宁静到动荡的年代里，用平实细腻的文笔，描绘了友谊背叛到亲情救赎过程，之所以引起读者的共鸣，是因为故事中召唤了一只每个人内心都会有却又不敢面对的魔鬼，而勇敢纯洁善良的哈桑，就是勇气的源泉；主人公最终直面这魔鬼，用自己的行动来为自己救赎，走上了“再次成为好人的路”。问谁无罪？问谁没有遗憾？我们大多都没有勇气为自己救赎，而阿米尔最终面对了自己的罪，这就是读者的共鸣。</p>

<p>起初买这本书，是名字吸引了我，追风筝的人；我本以为是一个梦幻，自由，清新的故事，可作者描绘的故事并没有让人失望。其实所谓看书，就是在看文字上表现出来的氛围，有了这氛围才能烘托出更多的情感，才能把最神的那段情感镶入读者的脑海中。《追风筝的人》其实不只是背叛与救赎，还有父子、历史、伦理、信仰等等，但救赎就是最深沉的情感。会编故事的人不一定能够成为好的编剧。我身边有些人，文字天赋仿佛与生俱来，写下的一段文字，自然而生动，让人读之畅快，不需细细思考品位，得其形即明其意，可惜大多荒废，不然便是慢慢变得造作。</p>

<p>“为你，千千万万遍！”</p></p>

<p>11 Apr 2013</p>

]]></content:encoded>
    </item>
    
    <item>
      <title>UITableView 快速滑动和简化控制器 ——《iOS 6编程实战》读书笔记(3)</title>
      <link href="http://jaminzzhang.github.com/2013/03/31/Should-Use-IB/"/>
      <pubDate>2013-03-31T00:00:00+08:00</pubDate>
      <author>jaminzzhang</author>
      <guid>http://jaminzzhang.github.com/2013/03/31/Should-Use-IB</guid>
      <content:encoded><![CDATA[<h2>UITableView 快速滑动和简化控制器 ——《iOS 6编程实战》读书笔记(3)</h2>


<hr />

<h3>1、提高UITableView的滚动速度</h3>

<p>提高UITableView滚动速度的要点就是：每个Cell只使用一个Custom View，而这个View所有的内容都通过重写drawRect方法直接画上去。这是因为GPU渲染时，透明的混合图层会非常耗费资源。而drawRect是在做预渲染的工作。</p>

<p>可以使用Instruments中的Core Animation来比较有半透明混合图层和没有半透明混合图层的TableView滑动的帧数（勾选Color Blended Layers 可以看到标记会红色的半透明图层，如图）。勾选会发现使用drawRect画上去的tableView滚动帧数更大。</p>

<p><img src="/assets/images/2013-03-31-Should-Use-IB/iphone_render.png" alt="Color Blended Layers 展示的图片" /></p>

<p>Color Blended Layers 展示的图片</p>

<p>相关的阅读：<a href="http://blog.atebits.com/2008/12/fast-scrolling-in-tweetie-with-uitableview/">http://blog.atebits.com/2008/12/fast-scrolling-in-tweetie-with-uitableview</a> (这个连接貌似打不开了，可以打开：<a href="http://atebits.tumblr.com/post/197580827/fast-scrolling-in-tweetie-with-uitableview">http://atebits.tumblr.com/post/197580827/fast-scrolling-in-tweetie-with-uitableview</a>)</p>

<h3>2、简化控制器内容</h3>

<p>使用UITableView时，遇到处理复杂的非重复表单元，或者是在同一界面需要使用多个UITableView时，假如使用一个控制器（UIViewController）进行控制，就会让控制器代码变得庞大复杂，所以在设计和重构时需要考虑相关问题。处理这些问题的方法主要有两种：</p>

<p>1.<strong>数据绑定:</strong> 即，将不同类型Cell需要展示的数据绑定到不同的子视图Cell上，简化控制器的代码维护工作。如RSS阅读器展示推送信息的FeedCell：
FeedCell中绑定数据的方法：</p>

<p><code>
-(void) bindFeed:(Feed*) feedToBeDisplayed {
    self.titleLabel.text = feedToBeDisplayed.text;    
    self.timeStampLabel.text = feedToBeDisplayed.modifiedDateString;
    ...
}</code></p>

<p>这个绑定方法可以可以在Cell的子类里做，也可以使用Category分类类来实现。如需要显示订阅，则使用bindSubscription:(Subscription*)subsription这样的绑定方式。假如使用了UITableViewCell的子类，需要显示更不同的Feed类，如TechFeed，可以用protocol定义接口来进行泛绑定：-(void) bindFeed:(id)feed，以便子类继承重载。</p>

<p>2.使用多个UITableView时，注意将每个UITableView使用独立的控制器来管理对应的委托（delegate）和数据源（datasource），防止对个UITableView的委托和数据源混合。</p>

<p>PS:控制器应该在模型与UI元素（在当前层定义的，而不是在子类层级定义的）之间扮演中介的角色。即UIViewController可以设置当前作用域内定义的的UI元素属性，而不要对子视图这样做。如
<code>self.textLabel.text = NSLocalizedString(@"Hello", @"")</code> 是正确的代码，而<code>self.customView.textLabel.text = NSLocalizedString(@"Hello", @"")</code>则推荐使用绑定来实现。]]></p>

<p>31 Mar 2013</p>

]]></content:encoded>
    </item>
    
    <item>
      <title>是否使用Interface Builder</title>
      <link href="http://jaminzzhang.github.com/2013/03/31/%3CiOS6-Note3%3EUITableView-Scroll/"/>
      <pubDate>2013-03-31T00:00:00+08:00</pubDate>
      <author>jaminzzhang</author>
      <guid>http://jaminzzhang.github.com/2013/03/31/<iOS6-Note3>UITableView-Scroll</guid>
      <content:encoded><![CDATA[<h2>是否使用Interface Builder</h2>




<p>在《iOS6 编程实战》，“第6章 熟练使用表视图” 一章中对是否使用Interface Builder做了讨论(p76)

首先要确认的概念是：IB不是一个代码生成器，而是能将视图生成为基于XML格式归档文件的编辑器。大部分情况，nib文件不会比等效编码生成的UI性能更低。使用IB的优点：
<ol>
    <li><span style="line-height: 14px;">nib文件可以将“视图”独立成单个文件，并且方便直观地管理。</span></li>
    <li>直观的界面展示，方便代码与设计分离。</li>
    <li>适合新手学习。</li>
</ol>
撇开性能上面的考虑，个人并不推荐有经验的程序员使用Interface Builder，原因是：
<ol>
    <li><span style="line-height: 14px;">手动编码同样可以将某个视图进行抽象独立，以便管理；</span></li>
    <li>相比于在IB去做各种属性和frame的手动调整，分层良好的代码会更加清晰。特别是需要对不同rotation调整界面的时候。</li>
    <li>使用IB不利于泛化复用。比如需要对某个控件进行继承以实现新功能时，IB明显没办法做到。</li>
    <li>方便修改，如某个button需要更换或添加controlEvent触发事件时，需要同时修改代码和nib文件，而手动编码的话，只需要修改一个.m文件。</li>
    <li>还没想好</li>
</ol>
以上只是个人的一些经验之谈，假如有不对的地方，请不吝指正。
</p>


<p>31 Mar 2013</p>

]]></content:encoded>
    </item>
    
    <item>
      <title>纪念 For Blankyao</title>
      <link href="http://jaminzzhang.github.com/2013/03/28/For-Blankyao/"/>
      <pubDate>2013-03-28T00:00:00+08:00</pubDate>
      <author>jaminzzhang</author>
      <guid>http://jaminzzhang.github.com/2013/03/28/For-Blankyao</guid>
      <content:encoded><![CDATA[<h2>纪念 For Blankyao</h2>




<p><p>今天，雷声轰轰，细雨绵绵，Blank办完了离职手续。2013年3月28日下午16时24分，一众朋友的集体拥簇欢送下，他搭上13楼的电梯，通往他新的路途。</p>

<p>&nbsp;</p>

<p><a href="http://blankyao.com" target="_blank">Blankyao</a>，1990年出生，山东人，2006年进入合肥工业大学工程力学专业，因志向远大——成为一名万人敬仰的码农，弃暗投明，未毕业，就辗转北京杭州，住地下室，帮人打杂做技工，混口饭吃；2010年6月，因相貌英俊，仪表堂堂，被腾讯一高层MM相中，费尽心机，力排众议，将其校招进麾下，意欲委以重任。奈何Blank心有所属，不贪财色，宁死不屈，MM愤而将其发配，便开始了其不羁的职途；其后历经坎坷，涉猎前端后台，研究android iphone，终于成为了一名技工中技师工，码农中的码赛农，屌丝中的屌布丝。虽将其发配，但MM仍对Blank仍念念不忘，盼其回心转意，Blank不厌其烦，只能沉溺于桌上足球，借虐消愁；潜龙卧渊，伏虎困窟，Blank终于放出那天的豪言：“混的好我就不回来了！”，快步奔向美好未来。自此，江湖中便有了他的传说。</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>上文一篇野传，简介了Blank平淡而不平凡，传说而未传奇的出身，或许后面的他，会更加精彩，可惜无法与他一起共谋大事，只能是一个旁观者。期待他成为姚布斯的一天，那样的话，我便可以写他的野传买点钱了。</p>

<p>&nbsp;</p>

<p>2012年3月，Blank初面把我招入公司，至此，刚好满一年，这或许是我纪念的一个原因；而更多的是，他是现实中的理想主义者，也许并不完全是，但至少可以经常在他身上看到，催着你停不了脚步。他喜欢这个行业，关注这个行业，思考这个行业，更重要的是他会追求他想要的生活：比如，大学学力学，直接跑去学计算机；比如，他这次辞职，跑去创业。也许这种勇气并不少见，当下创业者如过江之鲤，但我欣赏的是他这份追求自己生活的理想主义。我们大多数人，都喜欢呆在自己的舒适区，包括我，自觉安全稳定，害怕改变，恐惧未知；也许这个舒适区就是你想要的生活，但生活对于我们本来就不是一成不变的。</p>

<p>&nbsp;</p>

<p>我纪念他，因为这样可以成为亦师亦友的人，你生命中不会遇到多少个。我没有想成为他这样的人，因为我就是这样的人。我的路，我自己走！不管混的好不好。</p>

<p>&nbsp;</p>

<p>Blankyao博客：<a title="http://blog.blankyao.com" href="http://blog.blankyao.com" target="_blank">http://blog.blankyao.com</a>]]>/p></p>

<p><p>28 Mar 2013</p></p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
